{
    "sourceFile": "source/CPP_Reconfig/util/environment.hpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1687723602865,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1687723724113,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -269,9 +269,9 @@\n             return has_mut_exist;\r\n         }\r\n         bool remove(string MutexName)\r\n         {\r\n-            \r\n+            AllMutexHandles\r\n         }\r\n     }\r\n \r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1687727098448,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -282,8 +282,9 @@\n                 it++;\r\n             }\r\n             return has(MutexName);\r\n         }\r\n+        /\r\n         vector<string> list()\r\n         {\r\n             vector<string> list;\r\n             map<string, HANDLE>::iterator it = AllMutexHandles.begin();\r\n"
                }
            ],
            "date": 1687723602865,
            "name": "Commit-0",
            "content": "#include <string>\r\n#include <vector>\r\n#include <windows.h>\r\n#include <filesystem>\r\n#include <shlwapi.h>\r\n#include <processenv.h>\r\n#include <map>\r\n#include <regex>\r\n\r\n#include \"./text.hpp\"\r\nusing namespace hmc_text_util;\r\n\r\nusing namespace std;\r\n\r\nmap<string, HANDLE> AllMutexHandles;\r\n\r\n\r\n// 获取指定的环境变量\r\nstring GetVariable(string const &name)\r\n{\r\n#if defined(_MSC_VER)\r\n    size_t size;\r\n    getenv_s(&size, nullptr, 0, name.c_str());\r\n    if (size > 0)\r\n    {\r\n        vector<char> tmpvar(size);\r\n        errno_t result = getenv_s(&size, tmpvar.data(), size, name.c_str());\r\n        string var = (result == 0 ? string(tmpvar.data()) : \"\");\r\n        return var;\r\n    }\r\n    else\r\n    {\r\n        return \"\";\r\n    }\r\n#else\r\n    char const *variable = getenv(name.c_str());\r\n    return variable ? string(variable) : string(\"\");\r\n#endif\r\n}\r\n\r\n// 二进制编译的版本\r\nstring GetBinaryArch()\r\n{\r\n#if _WIN32\r\n    return string(\"x32\");\r\n#elif _WIN64\r\n    return string(\"x64\");\r\n#else\r\n    return string(\"ia32\");\r\n#endif\r\n}\r\n\r\n// 判断 x64 系统\r\nBOOL isSystemFor64bit()\r\n{\r\n    SYSTEM_INFO SystemInfo;\r\n    ::GetNativeSystemInfo(&SystemInfo);\r\n    if (SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64 || SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)\r\n        return TRUE;\r\n    else\r\n        return FALSE;\r\n}\r\n\r\nmap<string, string> getVariableAll()\r\n{\r\n    map<string, string> envStrMap;\r\n\r\n    // 注意这里A字符很乱 请勿改成A （OEM ，Unicode ，ANSI）\r\n    LPWSTR env = GetEnvironmentStringsW();\r\n\r\n    while (*env)\r\n    {\r\n        wstring pwText = wstring(env);\r\n\r\n        if (pwText.empty() && pwText.find(L'=') == 0)\r\n            continue;\r\n\r\n        int pszATextLen = WideCharToMultiByte(CP_ACP, 0, pwText.c_str(), -1, NULL, 0, NULL, NULL);\r\n        char *pAChar = new (nothrow) char[pszATextLen];\r\n\r\n        ZeroMemory(pAChar, pszATextLen + 1);\r\n        WideCharToMultiByte(CP_ACP, 0, pwText.c_str(), -1, pAChar, pszATextLen, NULL, NULL);\r\n        string strEnv = string(pAChar);\r\n        delete[] pAChar;\r\n        pAChar = NULL;\r\n        if (!strEnv.empty() && string(&strEnv.at(0)) != string(\"=\"))\r\n        {\r\n            size_t pos = strEnv.find('=');\r\n            if (pos != string::npos)\r\n            {\r\n                string name = strEnv.substr(0, pos);\r\n                string value = strEnv.substr(pos + 1);\r\n                envStrMap.insert(pair<string, string>(name, value));\r\n            }\r\n        }\r\n        env += wcslen(env) + 1;\r\n    }\r\n}\r\n\r\nnamespace hmc_env\r\n{\r\n    /**\r\n     * @brief 获取环境变量值\r\n     *\r\n     * @param name\r\n     * @return string\r\n     */\r\n    string getenv(string const &name)\r\n    {\r\n        return GetVariable(name);\r\n    }\r\n    /**\r\n     * @brief 获取命令行\r\n     *\r\n     * @return string\r\n     */\r\n    string getcmd()\r\n    {\r\n        LPSTR commandStr = ::GetCommandLineA();\r\n        return string(commandStr);\r\n    }\r\n    /**\r\n     * @brief 获取pid\r\n     *\r\n     * @return DWORD\r\n     */\r\n    DWORD getpid()\r\n    {\r\n        DWORD processId = ::GetCurrentProcessId();\r\n        return processId;\r\n    }\r\n    /**\r\n     * @brief 获取ppid\r\n     *\r\n     * @return DWORD\r\n     */\r\n    DWORD getppid()\r\n    {\r\n        //  DWORD processId = ::get();\r\n        // return processId;\r\n    }\r\n    /**\r\n     * @brief 获取工作目录\r\n     *\r\n     * @return DWORD\r\n     */\r\n    string getcwd()\r\n    {\r\n        string cwdPath;\r\n        char buffer[MAX_PATH] = {0};\r\n        DWORD size = ::GetCurrentDirectoryA(MAX_PATH, buffer);\r\n        if (size > 0)\r\n        {\r\n            cwdPath.append(buffer);\r\n            return cwdPath;\r\n        }\r\n        else\r\n        {\r\n            filesystem::path cwd = filesystem::current_path();\r\n            cwdPath.append(cwd.string());\r\n        }\r\n        return cwdPath;\r\n    }\r\n    /**\r\n     * @brief 获取可执行文件位置\r\n     *\r\n     * @return DWORD\r\n     */\r\n    string getexecPath()\r\n    {\r\n        string execFilePath = string();\r\n        LPSTR lpFilename;\r\n        ::GetModuleFileNameA(nullptr, lpFilename, MAX_PATH);\r\n        execFilePath.append(lpFilename);\r\n        return execFilePath;\r\n    }\r\n    /**\r\n     * @brief 获取可执行文件所在的文件夹\r\n     *\r\n     * @return DWORD\r\n     */\r\n    string getexecDirPath()\r\n    {\r\n        string execDirPath = string();\r\n\r\n        LPSTR lpFilename;\r\n        ::GetModuleFileNameA(nullptr, lpFilename, MAX_PATH);\r\n        ::PathRemoveFileSpecA(lpFilename);\r\n\r\n        execDirPath.append(lpFilename);\r\n        return execDirPath;\r\n    }\r\n    /**\r\n     * @brief 获取编译的二进制平台(有些人会在x64机器跑x32应用 就很迷惑)\r\n     *\r\n     */\r\n    string getbinArch()\r\n    {\r\n        return GetBinaryArch();\r\n    }\r\n    /**\r\n     * @brief 获取当前应用的平台\r\n     *\r\n     * @return string\r\n     */\r\n    string getarch()\r\n    {\r\n        return (isSystemFor64bit() ? \"x64\" : \"x32\");\r\n    }\r\n    /**\r\n     * @brief 添加环境变量 请注意这会传递到所有子进程\r\n     *\r\n     * @param key\r\n     * @param Value\r\n     * @return true\r\n     * @return false\r\n     */\r\n    bool putenv(string key, string Value)\r\n    {\r\n        int b_Result = _putenv_s(key.c_str(), Value.c_str());\r\n        return b_Result == 0;\r\n    }\r\n    /**\r\n     * @brief Get the Env object\r\n     *\r\n     * @return map<string, string>\r\n     */\r\n    map<string, string> getEnv()\r\n    {\r\n        return getVariableAll();\r\n    }\r\n\r\n    bool CreateMutex(string MutexName)\r\n    {\r\n        bool has_mut_exist = false;\r\n\r\n        HANDLE hMutex = CreateMutexA(NULL, FALSE, MutexName.c_str());\r\n        AllMutexHandles.insert(pair<string,HANDLE >(MutexName,hMutex));\r\n        if (hMutex == NULL)\r\n        {\r\n            has_mut_exist = true;\r\n        }\r\n        // 检查是否已经存在同名的互斥体\r\n        if (GetLastError() == ERROR_ALREADY_EXISTS)\r\n        {\r\n            has_mut_exist = true;\r\n            CloseHandle(hMutex);\r\n        }\r\n\r\n        return !has_mut_exist;\r\n    }\r\n\r\n    bool HasMutex(string MutexName)\r\n    {\r\n        bool has_mut_exist = true;\r\n\r\n        HANDLE hMutex;\r\n\r\n        hMutex = OpenMutexA(MUTEX_ALL_ACCESS, FALSE, MutexName.c_str());\r\n        if (NULL == hMutex)\r\n        {\r\n            has_mut_exist = false;\r\n        }\r\n\r\n        CloseHandle(hMutex);\r\n        return has_mut_exist;\r\n    }\r\n\r\n}"
        }
    ]
}