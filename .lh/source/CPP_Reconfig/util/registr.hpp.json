{
    "sourceFile": "source/CPP_Reconfig/util/registr.hpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1690359392208,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1690359392208,
            "name": "Commit-0",
            "content": "#include <windows.h>\r\n#include <iostream>\r\n#include <set>\r\n#include <string>\r\n#include <map>\r\n#include <vector>\r\n#include <type_traits>\r\n\r\nusing namespace std;\r\n\r\n#define MAX_KEY_LENGTH 255\r\n#define MAX_VALUE_NAME 16383\r\n\r\n#define _define_if_to_break(eq1, result)                      \\\r\n    {                                                         \\\r\n        if (!is_ok || pDataSize == 0 || is_open == 0 || !eq1) \\\r\n            return result;                                    \\\r\n    }\r\n\r\n#define _define_is_int32bit(T)         \\\r\n    (                                  \\\r\n        is_same_v<T, int64_t> ||       \\\r\n        is_same_v<T, long long> ||     \\\r\n        is_same_v<T, int32_t> ||       \\\r\n        is_same_v<T, size_t> ||        \\\r\n        is_same_v<T, unsigned long> || \\\r\n        is_same_v<T, HWND> ||          \\\r\n        is_same_v<T, long> ||          \\\r\n        is_same_v<T, long int> ||      \\\r\n        is_same_v<T, unsigned long>)\r\n\r\n#define _define_is_int64bit(T)         \\\r\n    (                                  \\\r\n        is_same_v<T, int64_t> ||       \\\r\n        is_same_v<T, long long> ||     \\\r\n        is_same_v<T, int32_t> ||       \\\r\n        is_same_v<T, size_t> ||        \\\r\n        is_same_v<T, unsigned long> || \\\r\n        is_same_v<T, HWND> ||          \\\r\n        is_same_v<T, long> ||          \\\r\n        is_same_v<T, long int> ||      \\\r\n        is_same_v<T, unsigned long>)\r\n\r\n// 关闭注册表键\r\n#define _defined_aoto_free_HKey(subHKey)            \\\r\n    shared_ptr<void> close_key(nullptr, [&](void *) \\\r\n                               {\\\r\n        if (subHKey != nullptr) {\\\r\n            ::RegCloseKey(subHKey);\\\r\n            subHKey = nullptr;\\\r\n        } });\r\n\r\nnamespace hmc_registr\r\n{\r\n    // 目录的信息\r\n    struct chQueryDirStat\r\n    {\r\n        string path; // 路径\r\n        string hkey; // 根名称\r\n        bool success;\r\n        long long LastWriteTime; // 上次写入时间的时间戳\r\n    };\r\n\r\n    // 枚举键\r\n    struct chQueryDirKey\r\n    {\r\n        vector<string> key;\r\n        vector<string> dir;\r\n    };\r\n\r\n    // 遍历树结构的信息 但是不返回内容\r\n    struct chWalkItemCout\r\n    {\r\n        DWORD size;     // 值的大小\r\n        string vkey;    // 值的名称\r\n        string dirPath; // 路径文件夹\r\n        DWORD type;     // 类型\r\n        HKEY root;      // 根路径\r\n        bool isDir;     // 是否是文件夹\r\n        long long time; // 时间戳\r\n    };\r\n\r\n    void _lib_EnumRegistrKeyQuery(HKEY hKey, vector<string> &QueryDirList, vector<string> &QueryKeyList);\r\n    HKEY getHive(string hkey);\r\n    string getHive(HKEY hkey);\r\n    chQueryDirStat getRegistrDirStat(HKEY hKey, string path);\r\n    chQueryDirKey listKey(HKEY hKey, string path);\r\n    bool path2hKey(string path, HKEY &hKey, string &p_path);\r\n\r\n    /**\r\n     * @brief 对比两个注册表类型能否被隐式转换\r\n     *\r\n     * @param reType 实际类型\r\n     * @param targetType 强制转换为\r\n     * @return true\r\n     * @return false\r\n     */\r\n    bool _EQ_REG_TYPE(DWORD reType, DWORD targetType)\r\n    {\r\n        switch (reType)\r\n        {\r\n        // 文本\r\n        case REG_LINK:\r\n        case REG_SZ:\r\n        case REG_MULTI_SZ:\r\n        case REG_EXPAND_SZ:\r\n        {\r\n            return targetType == REG_NONE || targetType == REG_LINK || targetType == REG_SZ || targetType == REG_MULTI_SZ || targetType == REG_EXPAND_SZ;\r\n        }\r\n        case REG_DWORD_BIG_ENDIAN:\r\n        case REG_QWORD:\r\n        case REG_DWORD:\r\n        {\r\n            return targetType == REG_NONE || targetType == REG_DWORD_BIG_ENDIAN || targetType == REG_QWORD || targetType == REG_DWORD;\r\n        }\r\n        case REG_BINARY:\r\n        case REG_RESOURCE_LIST:\r\n        case REG_RESOURCE_REQUIREMENTS_LIST:\r\n        {\r\n            return targetType == REG_NONE || targetType == REG_BINARY || targetType == REG_RESOURCE_LIST || targetType == REG_RESOURCE_REQUIREMENTS_LIST;\r\n        }\r\n\r\n        default:\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------------------------\r\n    /**\r\n     * @brief 枚举注册表的key\r\n     *\r\n     * @param hKey\r\n     * @param QueryDirList\r\n     * @param QueryKeyList\r\n     */\r\n    void _lib_EnumRegistrKeyQuery(HKEY hKey, vector<string> &QueryDirList, vector<string> &QueryKeyList)\r\n    {\r\n        try\r\n        {\r\n            char achKey[MAX_KEY_LENGTH];    // 子键名称的缓冲区\r\n            DWORD cbName = 0;               // 名称字符串的大小\r\n            char achClass[MAX_PATH] = \"\";   // 类名缓冲区\r\n            DWORD cchClassName = MAX_PATH;  // 类字符串的大小\r\n            DWORD cSubKeys = 0;             // 子键数\r\n            DWORD cbMaxSubKey = 0;          // 最长子键大小\r\n            DWORD cchMaxClass = 0;          // 最长类字符串\r\n            DWORD cValues = 0;              // 键值的个数\r\n            DWORD cchMaxValue = 0;          // 最长值名\r\n            DWORD cbMaxValueData = 0;       // 最长值数据\r\n            DWORD cbSecurityDescriptor = 0; // 安全描述符的大小\r\n            FILETIME ftLastWriteTime;       // 最后写入时间\r\n\r\n            char achValue[MAX_VALUE_NAME];   // key存储\r\n            DWORD cchValue = MAX_VALUE_NAME; // 数据序号\r\n\r\n            DWORD index, retCode;\r\n\r\n            // 获取类名和值计数。\r\n\r\n            retCode = RegQueryInfoKeyA(\r\n                hKey,                  // key句柄\r\n                achClass,              // 类名缓冲区\r\n                &cchClassName,         // 类字符串的大小\r\n                NULL,                  // 无\r\n                &cSubKeys,             // 子键数\r\n                &cbMaxSubKey,          // 最长子键大小\r\n                &cchMaxClass,          // 最长类字符串\r\n                &cValues,              // 键值的个数\r\n                &cchMaxValue,          // 最长值名\r\n                &cbMaxValueData,       // 最长值数据\r\n                &cbSecurityDescriptor, // 安全描述符的大小\r\n                &ftLastWriteTime);     // 最后写入时间\r\n\r\n            // 枚举子键，直到RegEnumKeyEx失败。\r\n            if (cSubKeys)\r\n            {\r\n\r\n                for (index = 0; index < cSubKeys; index++)\r\n                {\r\n                    cbName = MAX_KEY_LENGTH;\r\n                    retCode = RegEnumKeyExA(hKey, index,\r\n                                            achKey,\r\n                                            &cbName,\r\n                                            NULL,\r\n                                            NULL,\r\n                                            NULL,\r\n                                            &ftLastWriteTime);\r\n                    if (retCode == ERROR_SUCCESS)\r\n                    {\r\n                        QueryDirList.push_back(achKey);\r\n                    }\r\n                }\r\n            }\r\n            // 枚举键值。\r\n            if (cValues)\r\n            {\r\n                for (index = 0, retCode = ERROR_SUCCESS; index < cValues; index++)\r\n                {\r\n                    cchValue = MAX_VALUE_NAME;\r\n                    achValue[0] = '\\0';\r\n                    retCode = RegEnumValueA(hKey, index,\r\n                                            achValue,\r\n                                            &cchValue,\r\n                                            NULL,\r\n                                            NULL,\r\n                                            NULL,\r\n                                            NULL);\r\n\r\n                    if (retCode == ERROR_SUCCESS)\r\n                    {\r\n                        string str = string(achKey);\r\n                        str.resize(cchValue);\r\n                        for (size_t i = 0; i < cchValue; i++)\r\n                            str[i] = achValue[i];\r\n\r\n                        QueryKeyList.push_back(str);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        catch (const exception &e)\r\n        {\r\n        }\r\n    }\r\n    // ----------------------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * @brief 反HKEY解析 因为要和napi兼容\r\n     *\r\n     * @param hkey\r\n     * @return HKEY\r\n     */\r\n    HKEY getHive(string hkey)\r\n    {\r\n        if (hkey == \"HKEY_CURRENT_USER\")\r\n        {\r\n            return HKEY_CURRENT_USER;\r\n        }\r\n\r\n        if (hkey == \"HKEY_LOCAL_MACHINE\")\r\n        {\r\n            return HKEY_LOCAL_MACHINE;\r\n        }\r\n\r\n        if (hkey == \"HKEY_CLASSES_ROOT\")\r\n        {\r\n            return HKEY_CLASSES_ROOT;\r\n        }\r\n\r\n        if (hkey == \"HKEY_USERS\")\r\n        {\r\n            return HKEY_USERS;\r\n        }\r\n\r\n        if (hkey == \"HKEY_CURRENT_CONFIG\")\r\n        {\r\n            return HKEY_CURRENT_CONFIG;\r\n        }\r\n\r\n        return NULL;\r\n    }\r\n\r\n    /**\r\n     * @brief 反HKEY解析 因为要和napi兼容\r\n     *\r\n     * @param hkey\r\n     * @return string\r\n     */\r\n    string getHive(HKEY hkey)\r\n    {\r\n        if (hkey == HKEY_CURRENT_USER)\r\n        {\r\n            return \"HKEY_CURRENT_USER\";\r\n        }\r\n\r\n        if (hkey == HKEY_LOCAL_MACHINE)\r\n        {\r\n            return \"HKEY_LOCAL_MACHINE\";\r\n        }\r\n\r\n        if (hkey == HKEY_CLASSES_ROOT)\r\n        {\r\n            return \"HKEY_CLASSES_ROOT\";\r\n        }\r\n\r\n        if (hkey == HKEY_USERS)\r\n        {\r\n            return \"HKEY_USERS\";\r\n        }\r\n\r\n        if (hkey == HKEY_CURRENT_CONFIG)\r\n        {\r\n            return \"HKEY_CURRENT_CONFIG\";\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * @brief 获取目录的信息多少个 key 更新时间\r\n     *\r\n     * @param hKey\r\n     * @param path\r\n     * @return chQueryDirStat\r\n     */\r\n    chQueryDirStat getRegistrDirStat(HKEY hKey, string path)\r\n    {\r\n        chQueryDirStat queryDirStat = {\r\n            getHive(hKey),\r\n            path, false, 0};\r\n\r\n        try\r\n        {\r\n            HKEY hTestKey;\r\n            _defined_aoto_free_HKey(hTestKey);\r\n            if (RegOpenKeyExA(hKey, path.c_str(),\r\n                              0,\r\n                              KEY_READ,\r\n                              &hTestKey) == ERROR_SUCCESS)\r\n            {\r\n                char achKey[MAX_KEY_LENGTH];    // 子键名称的缓冲区\r\n                DWORD cbName = 0;               // 名称字符串的大小\r\n                char achClass[MAX_PATH] = \"\";   // 类名缓冲区\r\n                DWORD cchClassName = MAX_PATH;  // 类字符串的大小\r\n                DWORD cSubKeys = 0;             // 子键数\r\n                DWORD cbMaxSubKey = 0;          // 最长子键大小\r\n                DWORD cchMaxClass = 0;          // 最长类字符串\r\n                DWORD cValues = 0;              // 键值的个数\r\n                DWORD cchMaxValue = 0;          // 最长值名\r\n                DWORD cbMaxValueData = 0;       // 最长值数据\r\n                DWORD cbSecurityDescriptor = 0; // 安全描述符的大小\r\n                FILETIME ftLastWriteTime;       // 最后写入时间\r\n\r\n                RegQueryInfoKeyA(\r\n                    hKey,                  // key句柄\r\n                    achClass,              // 类名缓冲区\r\n                    &cchClassName,         // 类字符串的大小\r\n                    NULL,                  // 无\r\n                    &cSubKeys,             // 子键数\r\n                    &cbMaxSubKey,          // 最长子键大小\r\n                    &cchMaxClass,          // 最长类字符串\r\n                    &cValues,              // 键值的个数\r\n                    &cchMaxValue,          // 最长值名\r\n                    &cbMaxValueData,       // 最长值数据\r\n                    &cbSecurityDescriptor, // 安全描述符的大小\r\n                    &ftLastWriteTime);     // 最后写入时间\r\n\r\n                const ULONGLONG epochOffset = 116444736000000000ULL;\r\n                ULARGE_INTEGER uli;\r\n                uli.LowPart = ftLastWriteTime.dwLowDateTime;\r\n                uli.HighPart = ftLastWriteTime.dwHighDateTime;\r\n                ULONGLONG timestamp = (uli.QuadPart - epochOffset) / 10000ULL;\r\n                queryDirStat.success = true;\r\n                queryDirStat.LastWriteTime = static_cast<time_t>(timestamp);\r\n            }\r\n        }\r\n        catch (const exception &e)\r\n        {\r\n        }\r\n        return queryDirStat;\r\n    }\r\n\r\n    /**\r\n     * @brief 获取目录的信息多少个 key 更新时间\r\n     *\r\n     * @param path\r\n     * @return chQueryDirStat\r\n     */\r\n    chQueryDirStat getRegistrDirStat(string path)\r\n    {\r\n        HKEY hKey;\r\n        string p_path;\r\n        path2hKey(path, hKey, p_path);\r\n        return getRegistrDirStat(hKey, path);\r\n    }\r\n\r\n    /**\r\n     * @brief 枚举key\r\n     *\r\n     * @param hKey 根HKEY\r\n     * @param string 路径\r\n     * @return vector<string>\r\n     */\r\n    chQueryDirKey listKey(HKEY hKey, string path)\r\n    {\r\n        chQueryDirKey queryDirKey;\r\n\r\n        try\r\n        {\r\n            HKEY hTestKey;\r\n            _defined_aoto_free_HKey(hTestKey);\r\n            if (RegOpenKeyExA(hKey, path.c_str(),\r\n                              0,\r\n                              KEY_READ,\r\n                              &hTestKey) == ERROR_SUCCESS)\r\n            {\r\n                _lib_EnumRegistrKeyQuery(hTestKey, queryDirKey.dir, queryDirKey.key);\r\n            }\r\n        }\r\n        catch (const exception &e)\r\n        {\r\n        }\r\n\r\n        return queryDirKey;\r\n    }\r\n\r\n    /**\r\n     * @brief 枚举key\r\n     *\r\n     * @param path\r\n     * @return chQueryDirKey\r\n     */\r\n    chQueryDirKey listKey(string path)\r\n    {\r\n        HKEY hKey;\r\n        string p_path;\r\n        path2hKey(path, hKey, p_path);\r\n        return listKey(hKey, path);\r\n    }\r\n\r\n    /**\r\n     * @brief 分割文本\r\n     *\r\n     * @param path\r\n     * @return vector <string>\r\n     */\r\n    vector<string> _lib_splitString(string path, string sep = \"\\\\\")\r\n    {\r\n        vector<string> result;\r\n        string::size_type startPos = 0;\r\n        string::size_type endPos = path.find(sep);\r\n\r\n        while (endPos != string::npos)\r\n        {\r\n            result.push_back(path.substr(startPos, endPos - startPos));\r\n            startPos = endPos + 1;\r\n            endPos = path.find(sep, startPos);\r\n        }\r\n\r\n        result.push_back(path.substr(startPos));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @brief 路径合并为常规路径\r\n     *\r\n     * @param paths\r\n     * @return string\r\n     */\r\n    string _lib_joinString(vector<string> paths, string sep = \"\")\r\n    {\r\n\r\n        string newStr = string();\r\n\r\n        for (size_t i = 0; i < paths.size(); i++)\r\n        {\r\n            string path = paths[i];\r\n            newStr.append(path);\r\n            if (i != paths.size() - 1)\r\n                newStr.append(sep);\r\n        }\r\n\r\n        return newStr;\r\n    }\r\n\r\n    /**\r\n     * @brief 完整路径分析出HKEY和路径\r\n     *\r\n     * @param path\r\n     * @param hKey\r\n     * @param p_path\r\n     * @return true\r\n     * @return false\r\n     */\r\n    bool path2hKey(string path, HKEY &hKey, string &p_path)\r\n    {\r\n        bool result = false;\r\n        size_t pos = path.find('\\\\');\r\n        if (pos != 0)\r\n        {\r\n            string key1 = path.substr(0, pos);\r\n            HKEY hive = getHive(key1);\r\n            if (hive != NULL)\r\n            {\r\n                hKey = hive;\r\n            }\r\n            p_path.clear();\r\n            p_path.append(path.substr(pos, path.size() + 1));\r\n            result = true;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @brief 获取值类型与值路径\r\n     *\r\n     * @param hKey 根\r\n     * @param path 路径\r\n     * @param valueType 传址 DW\r\n     * - 0x00000000 REG_NONE 未定义\r\n     * - 0x00000001 REG_SZ 字符串\r\n     * - 0x00000002 REG_EXPAND_SZ 未展开引用的字符串 例如“%PATH%”\r\n     * - 0x00000003 REG_BINARY 二进制\r\n     * - 0x00000004 REG_DWORD / REG_DWORD_LITTLE_ENDIAN 32 位数字\r\n     * - 0x00000005 REG_DWORD_BIG_ENDIAN 大端格式的 32 位数字。\r\n     * - 0x00000006 REG_LINK   指向注册表项的符号链接。\r\n     * - 0x00000007 REG_MULTI_SZ      MS-RRP\r\n     * - 0x00000008 REG_RESOURCE_LIST 设备驱动程序资源列表\r\n     * - 0x0000000B REG_QWORD 64 位数字\r\n     * @param dataSize 传址 大小\r\n     * @return true\r\n     * @return false\r\n     */\r\n    bool getValueStat(HKEY hKey, string subKey, string key, DWORD &pValueType, DWORD &pDataSize)\r\n    {\r\n\r\n        pValueType = 0x00000000;\r\n        pDataSize = 0;\r\n        HKEY subHKey;\r\n        _defined_aoto_free_HKey(subHKey);\r\n        if (RegOpenKeyExA(hKey, subKey.c_str(), 0, KEY_READ, &subHKey) == ERROR_SUCCESS)\r\n        {\r\n\r\n            DWORD valueType;\r\n            DWORD dataSize = 0;\r\n\r\n            // 第一次调用 RegQueryValueEx 获取值的大小，放入 dataSize 变量中\r\n            if (RegQueryValueExA(subHKey, key.c_str(), nullptr, &valueType, nullptr, &dataSize) == ERROR_SUCCESS)\r\n            {\r\n                pValueType = valueType + 0;\r\n                pDataSize = dataSize + 0;\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @brief 设置内容 自识别或者自定义\r\n     *\r\n     * @tparam T 多种支持格式\r\n     * @param hKey 根\r\n     * @param subKey 目录\r\n     * @param key 键\r\n     * @param valueData 值\r\n     * @param retype 指定类型 默认自识别\r\n     * - 0x00000000 REG_NONE 未定义\r\n     * - 0x00000001 REG_SZ 字符串\r\n     * - 0x00000002 REG_EXPAND_SZ 未展开引用的字符串 例如“%PATH%”\r\n     * - 0x00000003 REG_BINARY 二进制\r\n     * - 0x00000004 REG_DWORD / REG_DWORD_LITTLE_ENDIAN 32 位数字\r\n     * - 0x00000005 REG_DWORD_BIG_ENDIAN 大端格式的 32 位数字。\r\n     * - 0x00000006 REG_LINK   指向注册表项的符号链接。\r\n     * - 0x00000007 REG_MULTI_SZ      MS-RRP\r\n     * - 0x00000008 REG_RESOURCE_LIST 设备驱动程序资源列表\r\n     * - 0x0000000B REG_QWORD 64 位数字\r\n     * @return true\r\n     * @return false\r\n     */\r\n    template <typename T>\r\n    bool setRegistrValue(HKEY hKey, string subKey, string key, const T &valueData, DWORD retype = 0)\r\n    {\r\n        bool result = false;\r\n\r\n        static_assert(\r\n            is_integral<T>::value ||\r\n                is_same_v<T, string> ||\r\n                is_same_v<T, vector<unsigned char>>,\r\n            \"Unsupported type preset escape (不支持的类型预设转义)\");\r\n\r\n        try\r\n        {\r\n            HKEY hSubKey;\r\n            DWORD dwDisposition;\r\n            DWORD is_open = ::RegCreateKeyExA(hKey, subKey.c_str(), 0, nullptr, REG_OPTION_NON_VOLATILE, KEY_WRITE, nullptr, &hSubKey, &dwDisposition);\r\n            _defined_aoto_free_HKey(hSubKey);\r\n            // 尝试创建或者打开父键\r\n            if (is_open == ERROR_SUCCESS)\r\n            {\r\n\r\n                // 数字小于 64 写入DWORD\r\n                if constexpr (_define_is_int32bit(T))\r\n                {\r\n                    DWORD newData = ((DWORD)valueData) + 0;\r\n                    is_open = ::RegSetValueExA(hSubKey, key.c_str(), 0, (retype != 0 ? retype : REG_DWORD), (LPBYTE)&newData, sizeof(DWORD));\r\n                }\r\n                // 写入64位数字\r\n                else if constexpr (_define_is_int64bit(T))\r\n                {\r\n                    long long newData = ((DWORD)valueData) + 0;\r\n                    is_open = ::RegSetValueExA(hSubKey, key.c_str(), 0, (retype != 0 ? retype : REG_QWORD), (LPBYTE)&newData, sizeof(int64_t));\r\n                }\r\n                // 写入文本\r\n                else if constexpr (is_same_v<T, string>)\r\n                {\r\n                    is_open = ::RegSetValueExA(hSubKey, key.c_str(), 0, (retype != 0 ? retype : REG_SZ), reinterpret_cast<const BYTE *>(valueData.c_str()), static_cast<DWORD>(string(valueData).size() * sizeof(char)));\r\n                }\r\n                // 写入二进制\r\n                else if constexpr (is_same_v<T, vector<BYTE>>)\r\n                {\r\n                    is_open = ::RegSetValueExA(hSubKey, key.c_str(), 0, (retype != 0 ? retype : REG_BINARY), reinterpret_cast<const BYTE *>(valueData.data()), static_cast<DWORD>(valueData.size() * sizeof(char)));\r\n                }\r\n\r\n                else\r\n                {\r\n                    is_open = 999;\r\n                }\r\n\r\n                result = is_open == ERROR_SUCCESS;\r\n                return result;\r\n            }\r\n        }\r\n        catch (const exception &e)\r\n        {\r\n            return result;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @brief 获取指定的值\r\n     * ? string  ->  getRegistrValue <string> (hKey, subKey,key);\r\n     * ? bin  ->  getRegistrValue< vector<BYTE> >(hKey, subKey,key);\r\n     * ? int  -> getRegistrValue <int> (hKey, subKey,key);\r\n     * ? REG_RESOURCE_REQUIREMENTS_LIST  ->  getRegistrValue< vector<BYTE> >(hKey, subKey,key);\r\n     * ? REG_RESOURCE_LIST  ->  getRegistrValue< vector<BYTE> >(hKey, subKey,key);\r\n     * - 读取为未转义变量\r\n     * ? string -> getRegistrValue <string> (hKey, 'subKey','key',REG_EXPAND_SZ);\r\n     * -\r\n     * @param hKey\r\n     * @param subKey\r\n     * @param key\r\n     * @return T <int , int8_t , int32_t , >\r\n     */\r\n    template <typename T>\r\n    T getRegistrValue(HKEY hKey, string subKey, string key, DWORD retype = 0)\r\n    {\r\n        T result_default = {0};\r\n        static_assert(\r\n            is_integral<T>::value ||\r\n                is_same_v<T, string> ||\r\n                is_same_v<T, vector<unsigned char>>,\r\n            \"Unsupported type preset escape (不支持的类型预设转义)\");\r\n\r\n        DWORD is_open;\r\n        DWORD pValueType;\r\n        DWORD pDataSize;\r\n        bool is_ok = false;\r\n        HKEY subHKey = 0;\r\n        is_ok = getValueStat(hKey, subKey, key, pValueType, pDataSize);\r\n\r\n        is_open = ::RegOpenKeyExA(hKey, subKey.c_str(), 0, KEY_READ, &subHKey) == ERROR_SUCCESS;\r\n\r\n        // 智能关闭指针\r\n        _defined_aoto_free_HKey(subHKey);\r\n\r\n        // 处理32位数字\r\n        if constexpr (_define_is_int32bit(T))\r\n        {\r\n            int32_t result = 0;\r\n\r\n            // 条件隐式转换匹配 不符合直接跳出\r\n            _define_if_to_break(_EQ_REG_TYPE(pValueType, retype), result);\r\n\r\n            DWORD type = retype == 0 ? REG_DWORD : retype;\r\n\r\n            long long value_data = 0;\r\n            if (type == 0)\r\n                type = REG_DWORD;\r\n\r\n            if (::RegQueryValueExA(subHKey, key.c_str(), 0, &type, reinterpret_cast<BYTE *>(&value_data), &pDataSize) == ERROR_SUCCESS)\r\n            {\r\n                result = (int32_t)value_data;\r\n                return result;\r\n            }\r\n            return result;\r\n        }\r\n        // 处理64位数字\r\n        else if constexpr (_define_is_int64bit(T))\r\n        {\r\n            long long result = 0;\r\n\r\n            // 条件隐式转换匹配 不符合直接跳出\r\n            _define_if_to_break(_EQ_REG_TYPE(pValueType, retype), result);\r\n            DWORD type = retype == 0 ? REG_QWORD : retype;\r\n\r\n            if (::RegQueryValueExA(subHKey, key.c_str(), 0, &type, reinterpret_cast<BYTE *>(&result), &pDataSize) == ERROR_SUCCESS)\r\n            {\r\n                return result;\r\n            }\r\n        }\r\n        // 处理文本型\r\n        else if constexpr (is_same_v<T, string>)\r\n        {\r\n            string result = string();\r\n\r\n            // 条件隐式转换匹配 不符合直接跳出\r\n            _define_if_to_break(_EQ_REG_TYPE(pValueType, retype), result);\r\n\r\n            DWORD type = retype == 0 ? REG_SZ : retype;\r\n\r\n            vector<BYTE> value_data(pDataSize);\r\n\r\n            if (::RegQueryValueExA(subHKey, key.c_str(), 0, &type, reinterpret_cast<BYTE *>(value_data.data()), &pDataSize) == ERROR_SUCCESS)\r\n            {\r\n                result.resize(pDataSize);\r\n                cout << value_data.size() << endl;\r\n                for (size_t i = 0; i < pDataSize; i++)\r\n                {\r\n                    result[i] = value_data[i];\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n        // 处理二进制\r\n        else if constexpr (is_same_v<T, vector<BYTE>>)\r\n        {\r\n            vector<BYTE> value_data(pDataSize);\r\n\r\n            _define_if_to_break(_EQ_REG_TYPE(pValueType, retype), value_data);\r\n\r\n            DWORD type = retype == 0 ? REG_BINARY : retype;\r\n\r\n            ::RegQueryValueExA(subHKey, key.c_str(), 0, &type, reinterpret_cast<BYTE *>(value_data.data()), &pDataSize);\r\n\r\n            return value_data;\r\n        }\r\n\r\n        return result_default;\r\n    }\r\n\r\n    /**\r\n     * @brief 判断是否存在此key\r\n     *\r\n     * @param hKey\r\n     * @param subKey\r\n     * @param key\r\n     * @return true\r\n     * @return false\r\n     */\r\n    bool hasRegistrKey(HKEY hKey, string subKey, string key)\r\n    {\r\n        bool result = false;\r\n\r\n        DWORD pValueType;\r\n        DWORD pDataSize;\r\n        result = getValueStat(hKey, subKey, key, pValueType, pDataSize);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @brief 判断是否存在此key\r\n     *\r\n     * @param hKey\r\n     * @param subKey\r\n     * @param key\r\n     * @return true\r\n     * @return false\r\n     */\r\n    bool hasRegistrDir(HKEY hKey, string subKey)\r\n    {\r\n        bool result = false;\r\n        HKEY hTestKey;\r\n        DWORD openResult = RegOpenKeyExA(hKey, subKey.c_str(), 0, KEY_READ, &hTestKey);\r\n        _defined_aoto_free_HKey(hTestKey);\r\n\r\n        switch (openResult)\r\n        {\r\n        case ERROR_SUCCESS:\r\n            return true;\r\n        case ERROR_FILE_NOT_FOUND:\r\n            return false;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @brief 删除指定的值\r\n     *\r\n     * @param hKey\r\n     * @param subKey\r\n     * @param key\r\n     * @return true\r\n     * @return false\r\n     */\r\n    bool removeRegistrValue(HKEY hKey, string subKey, string key)\r\n    {\r\n        HKEY open_hkey = nullptr;\r\n        _defined_aoto_free_HKey(open_hkey);\r\n        if (ERROR_SUCCESS == ::RegOpenKeyExA(hKey, subKey.c_str(), 0, KEY_ALL_ACCESS, &open_hkey))\r\n        {\r\n            return ::RegDeleteValueA(open_hkey, key.c_str()) == ERROR_SUCCESS;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @brief 删除注册表值树\r\n     *\r\n     * @param hKey\r\n     * @param subKey\r\n     * @return true\r\n     * @return false\r\n     */\r\n    bool removeRegistrTree(HKEY hKey, string subKey, string DirName)\r\n    {\r\n        HKEY open_hkey = nullptr;\r\n        _defined_aoto_free_HKey(open_hkey);\r\n        if (ERROR_SUCCESS == ::RegOpenKeyExA(hKey, subKey.c_str(), 0, KEY_ALL_ACCESS, &open_hkey))\r\n        {\r\n            RegDeleteTreeA(open_hkey, DirName.c_str());\r\n        }\r\n        return hasRegistrDir(hKey, subKey + \"\\\\\" + DirName) == false;\r\n    }\r\n\r\n    /**\r\n     * @brief 删除指定文件夹\r\n     *\r\n     * @param hKey\r\n     * @param subKey\r\n     * @param tree 是否删除所有\r\n     * @return true\r\n     * @return false\r\n     */\r\n    bool removeRegistrKey(HKEY hKey, string keyPath, bool tree = false)\r\n    {\r\n        HKEY open_hkey = nullptr;\r\n\r\n        if (tree)\r\n        {\r\n            vector<string> keys = _lib_splitString(keyPath);\r\n            if (keys.size() == 0)\r\n                return false;\r\n            string dirName = keys[keys.size() - 1];\r\n            keys.pop_back();\r\n            return removeRegistrTree(hKey, _lib_joinString(keys, \"\\\\\"), dirName);\r\n        }\r\n\r\n        LONG result = ::RegOpenKeyExA(HKEY_CURRENT_USER, keyPath.c_str(), 0, KEY_ALL_ACCESS, &open_hkey);\r\n        _defined_aoto_free_HKey(open_hkey);\r\n\r\n        if (result == ERROR_SUCCESS)\r\n        {\r\n            result = ::RegDeleteKeyExA(HKEY_CURRENT_USER, keyPath.c_str(), KEY_WOW64_64KEY, 0);\r\n            return (result == ERROR_SUCCESS) || (::RegDeleteKeyExA(HKEY_CURRENT_USER, keyPath.c_str(), KEY_WOW64_32KEY, 0) == ERROR_SUCCESS);\r\n        }\r\n        else\r\n        {\r\n            return false;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @brief 创建文件夹\r\n     *\r\n     * @param hKey\r\n     * @param keyPath\r\n     * @return true\r\n     * @return false\r\n     */\r\n    bool createRegistrDir(HKEY hKey, string keyPath)\r\n    {\r\n        HKEY open_hkey = nullptr;\r\n        DWORD dwOptions = REG_OPTION_NON_VOLATILE;\r\n        DWORD dwDisposition;\r\n        long resulte = RegCreateKeyExA(hKey, keyPath.c_str(), 0, NULL,\r\n                                       dwOptions, KEY_WRITE, NULL, &open_hkey, &dwDisposition);\r\n        if (resulte != ERROR_SUCCESS)\r\n        {\r\n            return false;\r\n        }\r\n        else\r\n        {\r\n            switch (dwDisposition)\r\n            {\r\n            case REG_OPENED_EXISTING_KEY:\r\n                return true;\r\n            case REG_CREATED_NEW_KEY:\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @brief 复制指定的目录到指定目录\r\n     *\r\n     * @param hKey\r\n     * @param sourcePath\r\n     * @param toPath\r\n     * @return true\r\n     * @return false\r\n     */\r\n    bool copyRegistrDir(HKEY hKey, string sourcePath, string toPath)\r\n    {\r\n        HKEY sourceHKey = nullptr;\r\n        HKEY toHKey = nullptr;\r\n        DWORD dwDisposition;\r\n\r\n        _defined_aoto_free_HKey(sourceHKey);\r\n        shared_ptr<void> close_toHKey(nullptr, [&](void *)\r\n                                      {\r\n        if (toHKey != nullptr) {\r\n            ::RegCloseKey(toHKey);\r\n            toHKey = nullptr;\r\n        } });\r\n\r\n        if (ERROR_SUCCESS != ::RegOpenKeyExA(hKey, sourcePath.c_str(), 0, KEY_ALL_ACCESS, &sourceHKey))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        if (ERROR_SUCCESS != ::RegCreateKeyExA(hKey, toPath.c_str(), 0, nullptr, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, nullptr, &toHKey, &dwDisposition))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        return (ERROR_SUCCESS == ::RegCopyTreeA(sourceHKey, nullptr, toHKey));\r\n    }\r\n\r\n    /**\r\n     * @brief 获取目录表中的键\r\n     *\r\n     * @param hKey\r\n     * @param keyPath\r\n     * @return true\r\n     * @return false\r\n     */\r\n    vector<chWalkItemCout> walkRegistrDir(HKEY hKey, string keyPath)\r\n    {\r\n        vector<chWalkItemCout> result;\r\n        try\r\n        {\r\n            HKEY hTestKey;\r\n            _defined_aoto_free_HKey(hTestKey);\r\n            vector<string> keylist;\r\n            vector<string> dirlist;\r\n\r\n            if (RegOpenKeyExA(hKey, keyPath.c_str(),\r\n                              0,\r\n                              KEY_READ,\r\n                              &hTestKey) == ERROR_SUCCESS)\r\n            {\r\n                _lib_EnumRegistrKeyQuery(hTestKey, dirlist, keylist);\r\n            }\r\n\r\n            // 枚举并获取信息\r\n            for (size_t i = 0; i < keylist.size(); i++)\r\n            {\r\n                chWalkItemCout walkItemCout;\r\n                string key = keylist[i];\r\n                walkItemCout.vkey = key;\r\n                walkItemCout.dirPath = keyPath;\r\n                walkItemCout.time = 0;\r\n                walkItemCout.isDir = false;\r\n                walkItemCout.root = hKey;\r\n\r\n                DWORD pValueType;\r\n                DWORD pDataSize;\r\n                getValueStat(hKey, keyPath, key, pValueType, pDataSize);\r\n                walkItemCout.size = pDataSize;\r\n                walkItemCout.type = pValueType;\r\n                result.push_back(walkItemCout);\r\n            }\r\n\r\n            // 枚举并获取信息\r\n            for (size_t i = 0; i < dirlist.size(); i++)\r\n            {\r\n                chWalkItemCout walkItemCout;\r\n                string dir = dirlist[i];\r\n                chQueryDirStat chqlist = getRegistrDirStat(hKey, string(keyPath).append(\"\\\\\").append(dir));\r\n                walkItemCout.vkey = dir;\r\n                walkItemCout.dirPath = keyPath;\r\n                walkItemCout.time = chqlist.LastWriteTime;\r\n                walkItemCout.isDir = true;\r\n                walkItemCout.root = hKey;\r\n                walkItemCout.size = 0;\r\n                walkItemCout.type = 0;\r\n                result.push_back(walkItemCout);\r\n            }\r\n        }\r\n        catch (const exception &e)\r\n        {\r\n            return result;\r\n        }\r\n\r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * @brief 从注册表读取系统变量\r\n     * \r\n     * @param key \r\n     * @return true \r\n     * @return false \r\n     */\r\n    bool getEnvVariable(string key){\r\n        \r\n\r\n    }\r\n\r\n    /**\r\n     * @brief 获取文本并带入环境\r\n     *\r\n     * @param path\r\n     * @return string\r\n     */\r\n    string escapeEnvVariable(string path)\r\n    {\r\n        string result = string();\r\n        vector<string> splitPath = _lib_splitString(path, \"%\");\r\n        vector<string> VariablePath = {};\r\n        if (splitPath.size() < 2)\r\n            return path;\r\n        for (size_t i = 0; i < splitPath.size(); i++)\r\n        {\r\n            string key = splitPath[i];\r\n            // 查找出 %。。。%\r\n            if (i % 2 == 1 && i)\r\n            {\r\n                VariablePath.push_back(key);\r\n            }\r\n        }\r\n\r\n        \r\n        cout << result << endl;\r\n        return result;\r\n    }\r\n};\r\n"
        }
    ]
}